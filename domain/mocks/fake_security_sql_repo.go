// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"database/sql"
	"sync"

	"github.com/DueIt-Jasanya-Aturuang/doraemon/domain/model"
	"github.com/DueIt-Jasanya-Aturuang/doraemon/domain/repository"
)

type FakeSecuritySqlRepo struct {
	CloseConnStub        func()
	closeConnMutex       sync.RWMutex
	closeConnArgsForCall []struct {
	}
	CreateTokenStub        func(context.Context, *model.Token) error
	createTokenMutex       sync.RWMutex
	createTokenArgsForCall []struct {
		arg1 context.Context
		arg2 *model.Token
	}
	createTokenReturns struct {
		result1 error
	}
	createTokenReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAllTokenByUserIDStub        func(context.Context, string) error
	deleteAllTokenByUserIDMutex       sync.RWMutex
	deleteAllTokenByUserIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteAllTokenByUserIDReturns struct {
		result1 error
	}
	deleteAllTokenByUserIDReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTokenStub        func(context.Context, string, string) error
	deleteTokenMutex       sync.RWMutex
	deleteTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteTokenReturns struct {
		result1 error
	}
	deleteTokenReturnsOnCall map[int]struct {
		result1 error
	}
	EndTxStub        func(error) error
	endTxMutex       sync.RWMutex
	endTxArgsForCall []struct {
		arg1 error
	}
	endTxReturns struct {
		result1 error
	}
	endTxReturnsOnCall map[int]struct {
		result1 error
	}
	GetConnStub        func() (*sql.Conn, error)
	getConnMutex       sync.RWMutex
	getConnArgsForCall []struct {
	}
	getConnReturns struct {
		result1 *sql.Conn
		result2 error
	}
	getConnReturnsOnCall map[int]struct {
		result1 *sql.Conn
		result2 error
	}
	GetTokenByIDAndUserIDStub        func(context.Context, string, string) (*model.Token, error)
	getTokenByIDAndUserIDMutex       sync.RWMutex
	getTokenByIDAndUserIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getTokenByIDAndUserIDReturns struct {
		result1 *model.Token
		result2 error
	}
	getTokenByIDAndUserIDReturnsOnCall map[int]struct {
		result1 *model.Token
		result2 error
	}
	GetTxStub        func() (*sql.Tx, error)
	getTxMutex       sync.RWMutex
	getTxArgsForCall []struct {
	}
	getTxReturns struct {
		result1 *sql.Tx
		result2 error
	}
	getTxReturnsOnCall map[int]struct {
		result1 *sql.Tx
		result2 error
	}
	OpenConnStub        func(context.Context) error
	openConnMutex       sync.RWMutex
	openConnArgsForCall []struct {
		arg1 context.Context
	}
	openConnReturns struct {
		result1 error
	}
	openConnReturnsOnCall map[int]struct {
		result1 error
	}
	StartTxStub        func(context.Context, *sql.TxOptions) error
	startTxMutex       sync.RWMutex
	startTxArgsForCall []struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}
	startTxReturns struct {
		result1 error
	}
	startTxReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateTokenStub        func(context.Context, *model.TokenUpdate) error
	updateTokenMutex       sync.RWMutex
	updateTokenArgsForCall []struct {
		arg1 context.Context
		arg2 *model.TokenUpdate
	}
	updateTokenReturns struct {
		result1 error
	}
	updateTokenReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSecuritySqlRepo) CloseConn() {
	fake.closeConnMutex.Lock()
	fake.closeConnArgsForCall = append(fake.closeConnArgsForCall, struct {
	}{})
	stub := fake.CloseConnStub
	fake.recordInvocation("CloseConn", []interface{}{})
	fake.closeConnMutex.Unlock()
	if stub != nil {
		fake.CloseConnStub()
	}
}

func (fake *FakeSecuritySqlRepo) CloseConnCallCount() int {
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	return len(fake.closeConnArgsForCall)
}

func (fake *FakeSecuritySqlRepo) CloseConnCalls(stub func()) {
	fake.closeConnMutex.Lock()
	defer fake.closeConnMutex.Unlock()
	fake.CloseConnStub = stub
}

func (fake *FakeSecuritySqlRepo) CreateToken(arg1 context.Context, arg2 *model.Token) error {
	fake.createTokenMutex.Lock()
	ret, specificReturn := fake.createTokenReturnsOnCall[len(fake.createTokenArgsForCall)]
	fake.createTokenArgsForCall = append(fake.createTokenArgsForCall, struct {
		arg1 context.Context
		arg2 *model.Token
	}{arg1, arg2})
	stub := fake.CreateTokenStub
	fakeReturns := fake.createTokenReturns
	fake.recordInvocation("CreateToken", []interface{}{arg1, arg2})
	fake.createTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) CreateTokenCallCount() int {
	fake.createTokenMutex.RLock()
	defer fake.createTokenMutex.RUnlock()
	return len(fake.createTokenArgsForCall)
}

func (fake *FakeSecuritySqlRepo) CreateTokenCalls(stub func(context.Context, *model.Token) error) {
	fake.createTokenMutex.Lock()
	defer fake.createTokenMutex.Unlock()
	fake.CreateTokenStub = stub
}

func (fake *FakeSecuritySqlRepo) CreateTokenArgsForCall(i int) (context.Context, *model.Token) {
	fake.createTokenMutex.RLock()
	defer fake.createTokenMutex.RUnlock()
	argsForCall := fake.createTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSecuritySqlRepo) CreateTokenReturns(result1 error) {
	fake.createTokenMutex.Lock()
	defer fake.createTokenMutex.Unlock()
	fake.CreateTokenStub = nil
	fake.createTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) CreateTokenReturnsOnCall(i int, result1 error) {
	fake.createTokenMutex.Lock()
	defer fake.createTokenMutex.Unlock()
	fake.CreateTokenStub = nil
	if fake.createTokenReturnsOnCall == nil {
		fake.createTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) DeleteAllTokenByUserID(arg1 context.Context, arg2 string) error {
	fake.deleteAllTokenByUserIDMutex.Lock()
	ret, specificReturn := fake.deleteAllTokenByUserIDReturnsOnCall[len(fake.deleteAllTokenByUserIDArgsForCall)]
	fake.deleteAllTokenByUserIDArgsForCall = append(fake.deleteAllTokenByUserIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteAllTokenByUserIDStub
	fakeReturns := fake.deleteAllTokenByUserIDReturns
	fake.recordInvocation("DeleteAllTokenByUserID", []interface{}{arg1, arg2})
	fake.deleteAllTokenByUserIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) DeleteAllTokenByUserIDCallCount() int {
	fake.deleteAllTokenByUserIDMutex.RLock()
	defer fake.deleteAllTokenByUserIDMutex.RUnlock()
	return len(fake.deleteAllTokenByUserIDArgsForCall)
}

func (fake *FakeSecuritySqlRepo) DeleteAllTokenByUserIDCalls(stub func(context.Context, string) error) {
	fake.deleteAllTokenByUserIDMutex.Lock()
	defer fake.deleteAllTokenByUserIDMutex.Unlock()
	fake.DeleteAllTokenByUserIDStub = stub
}

func (fake *FakeSecuritySqlRepo) DeleteAllTokenByUserIDArgsForCall(i int) (context.Context, string) {
	fake.deleteAllTokenByUserIDMutex.RLock()
	defer fake.deleteAllTokenByUserIDMutex.RUnlock()
	argsForCall := fake.deleteAllTokenByUserIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSecuritySqlRepo) DeleteAllTokenByUserIDReturns(result1 error) {
	fake.deleteAllTokenByUserIDMutex.Lock()
	defer fake.deleteAllTokenByUserIDMutex.Unlock()
	fake.DeleteAllTokenByUserIDStub = nil
	fake.deleteAllTokenByUserIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) DeleteAllTokenByUserIDReturnsOnCall(i int, result1 error) {
	fake.deleteAllTokenByUserIDMutex.Lock()
	defer fake.deleteAllTokenByUserIDMutex.Unlock()
	fake.DeleteAllTokenByUserIDStub = nil
	if fake.deleteAllTokenByUserIDReturnsOnCall == nil {
		fake.deleteAllTokenByUserIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAllTokenByUserIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) DeleteToken(arg1 context.Context, arg2 string, arg3 string) error {
	fake.deleteTokenMutex.Lock()
	ret, specificReturn := fake.deleteTokenReturnsOnCall[len(fake.deleteTokenArgsForCall)]
	fake.deleteTokenArgsForCall = append(fake.deleteTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteTokenStub
	fakeReturns := fake.deleteTokenReturns
	fake.recordInvocation("DeleteToken", []interface{}{arg1, arg2, arg3})
	fake.deleteTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) DeleteTokenCallCount() int {
	fake.deleteTokenMutex.RLock()
	defer fake.deleteTokenMutex.RUnlock()
	return len(fake.deleteTokenArgsForCall)
}

func (fake *FakeSecuritySqlRepo) DeleteTokenCalls(stub func(context.Context, string, string) error) {
	fake.deleteTokenMutex.Lock()
	defer fake.deleteTokenMutex.Unlock()
	fake.DeleteTokenStub = stub
}

func (fake *FakeSecuritySqlRepo) DeleteTokenArgsForCall(i int) (context.Context, string, string) {
	fake.deleteTokenMutex.RLock()
	defer fake.deleteTokenMutex.RUnlock()
	argsForCall := fake.deleteTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSecuritySqlRepo) DeleteTokenReturns(result1 error) {
	fake.deleteTokenMutex.Lock()
	defer fake.deleteTokenMutex.Unlock()
	fake.DeleteTokenStub = nil
	fake.deleteTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) DeleteTokenReturnsOnCall(i int, result1 error) {
	fake.deleteTokenMutex.Lock()
	defer fake.deleteTokenMutex.Unlock()
	fake.DeleteTokenStub = nil
	if fake.deleteTokenReturnsOnCall == nil {
		fake.deleteTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) EndTx(arg1 error) error {
	fake.endTxMutex.Lock()
	ret, specificReturn := fake.endTxReturnsOnCall[len(fake.endTxArgsForCall)]
	fake.endTxArgsForCall = append(fake.endTxArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.EndTxStub
	fakeReturns := fake.endTxReturns
	fake.recordInvocation("EndTx", []interface{}{arg1})
	fake.endTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) EndTxCallCount() int {
	fake.endTxMutex.RLock()
	defer fake.endTxMutex.RUnlock()
	return len(fake.endTxArgsForCall)
}

func (fake *FakeSecuritySqlRepo) EndTxCalls(stub func(error) error) {
	fake.endTxMutex.Lock()
	defer fake.endTxMutex.Unlock()
	fake.EndTxStub = stub
}

func (fake *FakeSecuritySqlRepo) EndTxArgsForCall(i int) error {
	fake.endTxMutex.RLock()
	defer fake.endTxMutex.RUnlock()
	argsForCall := fake.endTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecuritySqlRepo) EndTxReturns(result1 error) {
	fake.endTxMutex.Lock()
	defer fake.endTxMutex.Unlock()
	fake.EndTxStub = nil
	fake.endTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) EndTxReturnsOnCall(i int, result1 error) {
	fake.endTxMutex.Lock()
	defer fake.endTxMutex.Unlock()
	fake.EndTxStub = nil
	if fake.endTxReturnsOnCall == nil {
		fake.endTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) GetConn() (*sql.Conn, error) {
	fake.getConnMutex.Lock()
	ret, specificReturn := fake.getConnReturnsOnCall[len(fake.getConnArgsForCall)]
	fake.getConnArgsForCall = append(fake.getConnArgsForCall, struct {
	}{})
	stub := fake.GetConnStub
	fakeReturns := fake.getConnReturns
	fake.recordInvocation("GetConn", []interface{}{})
	fake.getConnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecuritySqlRepo) GetConnCallCount() int {
	fake.getConnMutex.RLock()
	defer fake.getConnMutex.RUnlock()
	return len(fake.getConnArgsForCall)
}

func (fake *FakeSecuritySqlRepo) GetConnCalls(stub func() (*sql.Conn, error)) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = stub
}

func (fake *FakeSecuritySqlRepo) GetConnReturns(result1 *sql.Conn, result2 error) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = nil
	fake.getConnReturns = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeSecuritySqlRepo) GetConnReturnsOnCall(i int, result1 *sql.Conn, result2 error) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = nil
	if fake.getConnReturnsOnCall == nil {
		fake.getConnReturnsOnCall = make(map[int]struct {
			result1 *sql.Conn
			result2 error
		})
	}
	fake.getConnReturnsOnCall[i] = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeSecuritySqlRepo) GetTokenByIDAndUserID(arg1 context.Context, arg2 string, arg3 string) (*model.Token, error) {
	fake.getTokenByIDAndUserIDMutex.Lock()
	ret, specificReturn := fake.getTokenByIDAndUserIDReturnsOnCall[len(fake.getTokenByIDAndUserIDArgsForCall)]
	fake.getTokenByIDAndUserIDArgsForCall = append(fake.getTokenByIDAndUserIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetTokenByIDAndUserIDStub
	fakeReturns := fake.getTokenByIDAndUserIDReturns
	fake.recordInvocation("GetTokenByIDAndUserID", []interface{}{arg1, arg2, arg3})
	fake.getTokenByIDAndUserIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecuritySqlRepo) GetTokenByIDAndUserIDCallCount() int {
	fake.getTokenByIDAndUserIDMutex.RLock()
	defer fake.getTokenByIDAndUserIDMutex.RUnlock()
	return len(fake.getTokenByIDAndUserIDArgsForCall)
}

func (fake *FakeSecuritySqlRepo) GetTokenByIDAndUserIDCalls(stub func(context.Context, string, string) (*model.Token, error)) {
	fake.getTokenByIDAndUserIDMutex.Lock()
	defer fake.getTokenByIDAndUserIDMutex.Unlock()
	fake.GetTokenByIDAndUserIDStub = stub
}

func (fake *FakeSecuritySqlRepo) GetTokenByIDAndUserIDArgsForCall(i int) (context.Context, string, string) {
	fake.getTokenByIDAndUserIDMutex.RLock()
	defer fake.getTokenByIDAndUserIDMutex.RUnlock()
	argsForCall := fake.getTokenByIDAndUserIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSecuritySqlRepo) GetTokenByIDAndUserIDReturns(result1 *model.Token, result2 error) {
	fake.getTokenByIDAndUserIDMutex.Lock()
	defer fake.getTokenByIDAndUserIDMutex.Unlock()
	fake.GetTokenByIDAndUserIDStub = nil
	fake.getTokenByIDAndUserIDReturns = struct {
		result1 *model.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeSecuritySqlRepo) GetTokenByIDAndUserIDReturnsOnCall(i int, result1 *model.Token, result2 error) {
	fake.getTokenByIDAndUserIDMutex.Lock()
	defer fake.getTokenByIDAndUserIDMutex.Unlock()
	fake.GetTokenByIDAndUserIDStub = nil
	if fake.getTokenByIDAndUserIDReturnsOnCall == nil {
		fake.getTokenByIDAndUserIDReturnsOnCall = make(map[int]struct {
			result1 *model.Token
			result2 error
		})
	}
	fake.getTokenByIDAndUserIDReturnsOnCall[i] = struct {
		result1 *model.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeSecuritySqlRepo) GetTx() (*sql.Tx, error) {
	fake.getTxMutex.Lock()
	ret, specificReturn := fake.getTxReturnsOnCall[len(fake.getTxArgsForCall)]
	fake.getTxArgsForCall = append(fake.getTxArgsForCall, struct {
	}{})
	stub := fake.GetTxStub
	fakeReturns := fake.getTxReturns
	fake.recordInvocation("GetTx", []interface{}{})
	fake.getTxMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSecuritySqlRepo) GetTxCallCount() int {
	fake.getTxMutex.RLock()
	defer fake.getTxMutex.RUnlock()
	return len(fake.getTxArgsForCall)
}

func (fake *FakeSecuritySqlRepo) GetTxCalls(stub func() (*sql.Tx, error)) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = stub
}

func (fake *FakeSecuritySqlRepo) GetTxReturns(result1 *sql.Tx, result2 error) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = nil
	fake.getTxReturns = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakeSecuritySqlRepo) GetTxReturnsOnCall(i int, result1 *sql.Tx, result2 error) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = nil
	if fake.getTxReturnsOnCall == nil {
		fake.getTxReturnsOnCall = make(map[int]struct {
			result1 *sql.Tx
			result2 error
		})
	}
	fake.getTxReturnsOnCall[i] = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakeSecuritySqlRepo) OpenConn(arg1 context.Context) error {
	fake.openConnMutex.Lock()
	ret, specificReturn := fake.openConnReturnsOnCall[len(fake.openConnArgsForCall)]
	fake.openConnArgsForCall = append(fake.openConnArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.OpenConnStub
	fakeReturns := fake.openConnReturns
	fake.recordInvocation("OpenConn", []interface{}{arg1})
	fake.openConnMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) OpenConnCallCount() int {
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	return len(fake.openConnArgsForCall)
}

func (fake *FakeSecuritySqlRepo) OpenConnCalls(stub func(context.Context) error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = stub
}

func (fake *FakeSecuritySqlRepo) OpenConnArgsForCall(i int) context.Context {
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	argsForCall := fake.openConnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSecuritySqlRepo) OpenConnReturns(result1 error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = nil
	fake.openConnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) OpenConnReturnsOnCall(i int, result1 error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = nil
	if fake.openConnReturnsOnCall == nil {
		fake.openConnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openConnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) StartTx(arg1 context.Context, arg2 *sql.TxOptions) error {
	fake.startTxMutex.Lock()
	ret, specificReturn := fake.startTxReturnsOnCall[len(fake.startTxArgsForCall)]
	fake.startTxArgsForCall = append(fake.startTxArgsForCall, struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}{arg1, arg2})
	stub := fake.StartTxStub
	fakeReturns := fake.startTxReturns
	fake.recordInvocation("StartTx", []interface{}{arg1, arg2})
	fake.startTxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) StartTxCallCount() int {
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	return len(fake.startTxArgsForCall)
}

func (fake *FakeSecuritySqlRepo) StartTxCalls(stub func(context.Context, *sql.TxOptions) error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = stub
}

func (fake *FakeSecuritySqlRepo) StartTxArgsForCall(i int) (context.Context, *sql.TxOptions) {
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	argsForCall := fake.startTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSecuritySqlRepo) StartTxReturns(result1 error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = nil
	fake.startTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) StartTxReturnsOnCall(i int, result1 error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = nil
	if fake.startTxReturnsOnCall == nil {
		fake.startTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) UpdateToken(arg1 context.Context, arg2 *model.TokenUpdate) error {
	fake.updateTokenMutex.Lock()
	ret, specificReturn := fake.updateTokenReturnsOnCall[len(fake.updateTokenArgsForCall)]
	fake.updateTokenArgsForCall = append(fake.updateTokenArgsForCall, struct {
		arg1 context.Context
		arg2 *model.TokenUpdate
	}{arg1, arg2})
	stub := fake.UpdateTokenStub
	fakeReturns := fake.updateTokenReturns
	fake.recordInvocation("UpdateToken", []interface{}{arg1, arg2})
	fake.updateTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSecuritySqlRepo) UpdateTokenCallCount() int {
	fake.updateTokenMutex.RLock()
	defer fake.updateTokenMutex.RUnlock()
	return len(fake.updateTokenArgsForCall)
}

func (fake *FakeSecuritySqlRepo) UpdateTokenCalls(stub func(context.Context, *model.TokenUpdate) error) {
	fake.updateTokenMutex.Lock()
	defer fake.updateTokenMutex.Unlock()
	fake.UpdateTokenStub = stub
}

func (fake *FakeSecuritySqlRepo) UpdateTokenArgsForCall(i int) (context.Context, *model.TokenUpdate) {
	fake.updateTokenMutex.RLock()
	defer fake.updateTokenMutex.RUnlock()
	argsForCall := fake.updateTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSecuritySqlRepo) UpdateTokenReturns(result1 error) {
	fake.updateTokenMutex.Lock()
	defer fake.updateTokenMutex.Unlock()
	fake.UpdateTokenStub = nil
	fake.updateTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) UpdateTokenReturnsOnCall(i int, result1 error) {
	fake.updateTokenMutex.Lock()
	defer fake.updateTokenMutex.Unlock()
	fake.UpdateTokenStub = nil
	if fake.updateTokenReturnsOnCall == nil {
		fake.updateTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSecuritySqlRepo) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	fake.createTokenMutex.RLock()
	defer fake.createTokenMutex.RUnlock()
	fake.deleteAllTokenByUserIDMutex.RLock()
	defer fake.deleteAllTokenByUserIDMutex.RUnlock()
	fake.deleteTokenMutex.RLock()
	defer fake.deleteTokenMutex.RUnlock()
	fake.endTxMutex.RLock()
	defer fake.endTxMutex.RUnlock()
	fake.getConnMutex.RLock()
	defer fake.getConnMutex.RUnlock()
	fake.getTokenByIDAndUserIDMutex.RLock()
	defer fake.getTokenByIDAndUserIDMutex.RUnlock()
	fake.getTxMutex.RLock()
	defer fake.getTxMutex.RUnlock()
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	fake.updateTokenMutex.RLock()
	defer fake.updateTokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSecuritySqlRepo) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repository.SecuritySqlRepo = new(FakeSecuritySqlRepo)

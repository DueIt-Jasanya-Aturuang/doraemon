// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"database/sql"
	"sync"

	"github.com/DueIt-Jasanya-Aturuang/doraemon/domain/model"
	"github.com/DueIt-Jasanya-Aturuang/doraemon/domain/repository"
)

type FakeUserSqlRepo struct {
	CheckActivasiUserByIDStub        func(context.Context, string) (bool, error)
	checkActivasiUserByIDMutex       sync.RWMutex
	checkActivasiUserByIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	checkActivasiUserByIDReturns struct {
		result1 bool
		result2 error
	}
	checkActivasiUserByIDReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CheckUserByEmailStub        func(context.Context, string) (bool, error)
	checkUserByEmailMutex       sync.RWMutex
	checkUserByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	checkUserByEmailReturns struct {
		result1 bool
		result2 error
	}
	checkUserByEmailReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CheckUserByUsernameStub        func(context.Context, string) (bool, error)
	checkUserByUsernameMutex       sync.RWMutex
	checkUserByUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	checkUserByUsernameReturns struct {
		result1 bool
		result2 error
	}
	checkUserByUsernameReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CloseConnStub        func()
	closeConnMutex       sync.RWMutex
	closeConnArgsForCall []struct {
	}
	CreateUserStub        func(context.Context, *model.User) error
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 context.Context
		arg2 *model.User
	}
	createUserReturns struct {
		result1 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 error
	}
	EndTxStub        func(error) error
	endTxMutex       sync.RWMutex
	endTxArgsForCall []struct {
		arg1 error
	}
	endTxReturns struct {
		result1 error
	}
	endTxReturnsOnCall map[int]struct {
		result1 error
	}
	GetConnStub        func() (*sql.Conn, error)
	getConnMutex       sync.RWMutex
	getConnArgsForCall []struct {
	}
	getConnReturns struct {
		result1 *sql.Conn
		result2 error
	}
	getConnReturnsOnCall map[int]struct {
		result1 *sql.Conn
		result2 error
	}
	GetTxStub        func() (*sql.Tx, error)
	getTxMutex       sync.RWMutex
	getTxArgsForCall []struct {
	}
	getTxReturns struct {
		result1 *sql.Tx
		result2 error
	}
	getTxReturnsOnCall map[int]struct {
		result1 *sql.Tx
		result2 error
	}
	GetUserByEmailStub        func(context.Context, string) (*model.User, error)
	getUserByEmailMutex       sync.RWMutex
	getUserByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByEmailReturns struct {
		result1 *model.User
		result2 error
	}
	getUserByEmailReturnsOnCall map[int]struct {
		result1 *model.User
		result2 error
	}
	GetUserByEmailOrUsernameStub        func(context.Context, string) (*model.User, error)
	getUserByEmailOrUsernameMutex       sync.RWMutex
	getUserByEmailOrUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByEmailOrUsernameReturns struct {
		result1 *model.User
		result2 error
	}
	getUserByEmailOrUsernameReturnsOnCall map[int]struct {
		result1 *model.User
		result2 error
	}
	GetUserByIDStub        func(context.Context, string) (*model.User, error)
	getUserByIDMutex       sync.RWMutex
	getUserByIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByIDReturns struct {
		result1 *model.User
		result2 error
	}
	getUserByIDReturnsOnCall map[int]struct {
		result1 *model.User
		result2 error
	}
	GetUserByUsernameStub        func(context.Context, string) (*model.User, error)
	getUserByUsernameMutex       sync.RWMutex
	getUserByUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByUsernameReturns struct {
		result1 *model.User
		result2 error
	}
	getUserByUsernameReturnsOnCall map[int]struct {
		result1 *model.User
		result2 error
	}
	OpenConnStub        func(context.Context) error
	openConnMutex       sync.RWMutex
	openConnArgsForCall []struct {
		arg1 context.Context
	}
	openConnReturns struct {
		result1 error
	}
	openConnReturnsOnCall map[int]struct {
		result1 error
	}
	StartTxStub        func(context.Context, *sql.TxOptions) error
	startTxMutex       sync.RWMutex
	startTxArgsForCall []struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}
	startTxReturns struct {
		result1 error
	}
	startTxReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateActivasiUserStub        func(context.Context, *model.User) error
	updateActivasiUserMutex       sync.RWMutex
	updateActivasiUserArgsForCall []struct {
		arg1 context.Context
		arg2 *model.User
	}
	updateActivasiUserReturns struct {
		result1 error
	}
	updateActivasiUserReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatePasswordUserStub        func(context.Context, *model.User) error
	updatePasswordUserMutex       sync.RWMutex
	updatePasswordUserArgsForCall []struct {
		arg1 context.Context
		arg2 *model.User
	}
	updatePasswordUserReturns struct {
		result1 error
	}
	updatePasswordUserReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserSqlRepo) CheckActivasiUserByID(arg1 context.Context, arg2 string) (bool, error) {
	fake.checkActivasiUserByIDMutex.Lock()
	ret, specificReturn := fake.checkActivasiUserByIDReturnsOnCall[len(fake.checkActivasiUserByIDArgsForCall)]
	fake.checkActivasiUserByIDArgsForCall = append(fake.checkActivasiUserByIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckActivasiUserByIDStub
	fakeReturns := fake.checkActivasiUserByIDReturns
	fake.recordInvocation("CheckActivasiUserByID", []interface{}{arg1, arg2})
	fake.checkActivasiUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) CheckActivasiUserByIDCallCount() int {
	fake.checkActivasiUserByIDMutex.RLock()
	defer fake.checkActivasiUserByIDMutex.RUnlock()
	return len(fake.checkActivasiUserByIDArgsForCall)
}

func (fake *FakeUserSqlRepo) CheckActivasiUserByIDCalls(stub func(context.Context, string) (bool, error)) {
	fake.checkActivasiUserByIDMutex.Lock()
	defer fake.checkActivasiUserByIDMutex.Unlock()
	fake.CheckActivasiUserByIDStub = stub
}

func (fake *FakeUserSqlRepo) CheckActivasiUserByIDArgsForCall(i int) (context.Context, string) {
	fake.checkActivasiUserByIDMutex.RLock()
	defer fake.checkActivasiUserByIDMutex.RUnlock()
	argsForCall := fake.checkActivasiUserByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) CheckActivasiUserByIDReturns(result1 bool, result2 error) {
	fake.checkActivasiUserByIDMutex.Lock()
	defer fake.checkActivasiUserByIDMutex.Unlock()
	fake.CheckActivasiUserByIDStub = nil
	fake.checkActivasiUserByIDReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) CheckActivasiUserByIDReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkActivasiUserByIDMutex.Lock()
	defer fake.checkActivasiUserByIDMutex.Unlock()
	fake.CheckActivasiUserByIDStub = nil
	if fake.checkActivasiUserByIDReturnsOnCall == nil {
		fake.checkActivasiUserByIDReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkActivasiUserByIDReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) CheckUserByEmail(arg1 context.Context, arg2 string) (bool, error) {
	fake.checkUserByEmailMutex.Lock()
	ret, specificReturn := fake.checkUserByEmailReturnsOnCall[len(fake.checkUserByEmailArgsForCall)]
	fake.checkUserByEmailArgsForCall = append(fake.checkUserByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckUserByEmailStub
	fakeReturns := fake.checkUserByEmailReturns
	fake.recordInvocation("CheckUserByEmail", []interface{}{arg1, arg2})
	fake.checkUserByEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) CheckUserByEmailCallCount() int {
	fake.checkUserByEmailMutex.RLock()
	defer fake.checkUserByEmailMutex.RUnlock()
	return len(fake.checkUserByEmailArgsForCall)
}

func (fake *FakeUserSqlRepo) CheckUserByEmailCalls(stub func(context.Context, string) (bool, error)) {
	fake.checkUserByEmailMutex.Lock()
	defer fake.checkUserByEmailMutex.Unlock()
	fake.CheckUserByEmailStub = stub
}

func (fake *FakeUserSqlRepo) CheckUserByEmailArgsForCall(i int) (context.Context, string) {
	fake.checkUserByEmailMutex.RLock()
	defer fake.checkUserByEmailMutex.RUnlock()
	argsForCall := fake.checkUserByEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) CheckUserByEmailReturns(result1 bool, result2 error) {
	fake.checkUserByEmailMutex.Lock()
	defer fake.checkUserByEmailMutex.Unlock()
	fake.CheckUserByEmailStub = nil
	fake.checkUserByEmailReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) CheckUserByEmailReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkUserByEmailMutex.Lock()
	defer fake.checkUserByEmailMutex.Unlock()
	fake.CheckUserByEmailStub = nil
	if fake.checkUserByEmailReturnsOnCall == nil {
		fake.checkUserByEmailReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkUserByEmailReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) CheckUserByUsername(arg1 context.Context, arg2 string) (bool, error) {
	fake.checkUserByUsernameMutex.Lock()
	ret, specificReturn := fake.checkUserByUsernameReturnsOnCall[len(fake.checkUserByUsernameArgsForCall)]
	fake.checkUserByUsernameArgsForCall = append(fake.checkUserByUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckUserByUsernameStub
	fakeReturns := fake.checkUserByUsernameReturns
	fake.recordInvocation("CheckUserByUsername", []interface{}{arg1, arg2})
	fake.checkUserByUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) CheckUserByUsernameCallCount() int {
	fake.checkUserByUsernameMutex.RLock()
	defer fake.checkUserByUsernameMutex.RUnlock()
	return len(fake.checkUserByUsernameArgsForCall)
}

func (fake *FakeUserSqlRepo) CheckUserByUsernameCalls(stub func(context.Context, string) (bool, error)) {
	fake.checkUserByUsernameMutex.Lock()
	defer fake.checkUserByUsernameMutex.Unlock()
	fake.CheckUserByUsernameStub = stub
}

func (fake *FakeUserSqlRepo) CheckUserByUsernameArgsForCall(i int) (context.Context, string) {
	fake.checkUserByUsernameMutex.RLock()
	defer fake.checkUserByUsernameMutex.RUnlock()
	argsForCall := fake.checkUserByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) CheckUserByUsernameReturns(result1 bool, result2 error) {
	fake.checkUserByUsernameMutex.Lock()
	defer fake.checkUserByUsernameMutex.Unlock()
	fake.CheckUserByUsernameStub = nil
	fake.checkUserByUsernameReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) CheckUserByUsernameReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkUserByUsernameMutex.Lock()
	defer fake.checkUserByUsernameMutex.Unlock()
	fake.CheckUserByUsernameStub = nil
	if fake.checkUserByUsernameReturnsOnCall == nil {
		fake.checkUserByUsernameReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkUserByUsernameReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) CloseConn() {
	fake.closeConnMutex.Lock()
	fake.closeConnArgsForCall = append(fake.closeConnArgsForCall, struct {
	}{})
	stub := fake.CloseConnStub
	fake.recordInvocation("CloseConn", []interface{}{})
	fake.closeConnMutex.Unlock()
	if stub != nil {
		fake.CloseConnStub()
	}
}

func (fake *FakeUserSqlRepo) CloseConnCallCount() int {
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	return len(fake.closeConnArgsForCall)
}

func (fake *FakeUserSqlRepo) CloseConnCalls(stub func()) {
	fake.closeConnMutex.Lock()
	defer fake.closeConnMutex.Unlock()
	fake.CloseConnStub = stub
}

func (fake *FakeUserSqlRepo) CreateUser(arg1 context.Context, arg2 *model.User) error {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 context.Context
		arg2 *model.User
	}{arg1, arg2})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1, arg2})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserSqlRepo) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeUserSqlRepo) CreateUserCalls(stub func(context.Context, *model.User) error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeUserSqlRepo) CreateUserArgsForCall(i int) (context.Context, *model.User) {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) CreateUserReturns(result1 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) CreateUserReturnsOnCall(i int, result1 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) EndTx(arg1 error) error {
	fake.endTxMutex.Lock()
	ret, specificReturn := fake.endTxReturnsOnCall[len(fake.endTxArgsForCall)]
	fake.endTxArgsForCall = append(fake.endTxArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.EndTxStub
	fakeReturns := fake.endTxReturns
	fake.recordInvocation("EndTx", []interface{}{arg1})
	fake.endTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserSqlRepo) EndTxCallCount() int {
	fake.endTxMutex.RLock()
	defer fake.endTxMutex.RUnlock()
	return len(fake.endTxArgsForCall)
}

func (fake *FakeUserSqlRepo) EndTxCalls(stub func(error) error) {
	fake.endTxMutex.Lock()
	defer fake.endTxMutex.Unlock()
	fake.EndTxStub = stub
}

func (fake *FakeUserSqlRepo) EndTxArgsForCall(i int) error {
	fake.endTxMutex.RLock()
	defer fake.endTxMutex.RUnlock()
	argsForCall := fake.endTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserSqlRepo) EndTxReturns(result1 error) {
	fake.endTxMutex.Lock()
	defer fake.endTxMutex.Unlock()
	fake.EndTxStub = nil
	fake.endTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) EndTxReturnsOnCall(i int, result1 error) {
	fake.endTxMutex.Lock()
	defer fake.endTxMutex.Unlock()
	fake.EndTxStub = nil
	if fake.endTxReturnsOnCall == nil {
		fake.endTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) GetConn() (*sql.Conn, error) {
	fake.getConnMutex.Lock()
	ret, specificReturn := fake.getConnReturnsOnCall[len(fake.getConnArgsForCall)]
	fake.getConnArgsForCall = append(fake.getConnArgsForCall, struct {
	}{})
	stub := fake.GetConnStub
	fakeReturns := fake.getConnReturns
	fake.recordInvocation("GetConn", []interface{}{})
	fake.getConnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) GetConnCallCount() int {
	fake.getConnMutex.RLock()
	defer fake.getConnMutex.RUnlock()
	return len(fake.getConnArgsForCall)
}

func (fake *FakeUserSqlRepo) GetConnCalls(stub func() (*sql.Conn, error)) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = stub
}

func (fake *FakeUserSqlRepo) GetConnReturns(result1 *sql.Conn, result2 error) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = nil
	fake.getConnReturns = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetConnReturnsOnCall(i int, result1 *sql.Conn, result2 error) {
	fake.getConnMutex.Lock()
	defer fake.getConnMutex.Unlock()
	fake.GetConnStub = nil
	if fake.getConnReturnsOnCall == nil {
		fake.getConnReturnsOnCall = make(map[int]struct {
			result1 *sql.Conn
			result2 error
		})
	}
	fake.getConnReturnsOnCall[i] = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetTx() (*sql.Tx, error) {
	fake.getTxMutex.Lock()
	ret, specificReturn := fake.getTxReturnsOnCall[len(fake.getTxArgsForCall)]
	fake.getTxArgsForCall = append(fake.getTxArgsForCall, struct {
	}{})
	stub := fake.GetTxStub
	fakeReturns := fake.getTxReturns
	fake.recordInvocation("GetTx", []interface{}{})
	fake.getTxMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) GetTxCallCount() int {
	fake.getTxMutex.RLock()
	defer fake.getTxMutex.RUnlock()
	return len(fake.getTxArgsForCall)
}

func (fake *FakeUserSqlRepo) GetTxCalls(stub func() (*sql.Tx, error)) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = stub
}

func (fake *FakeUserSqlRepo) GetTxReturns(result1 *sql.Tx, result2 error) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = nil
	fake.getTxReturns = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetTxReturnsOnCall(i int, result1 *sql.Tx, result2 error) {
	fake.getTxMutex.Lock()
	defer fake.getTxMutex.Unlock()
	fake.GetTxStub = nil
	if fake.getTxReturnsOnCall == nil {
		fake.getTxReturnsOnCall = make(map[int]struct {
			result1 *sql.Tx
			result2 error
		})
	}
	fake.getTxReturnsOnCall[i] = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByEmail(arg1 context.Context, arg2 string) (*model.User, error) {
	fake.getUserByEmailMutex.Lock()
	ret, specificReturn := fake.getUserByEmailReturnsOnCall[len(fake.getUserByEmailArgsForCall)]
	fake.getUserByEmailArgsForCall = append(fake.getUserByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByEmailStub
	fakeReturns := fake.getUserByEmailReturns
	fake.recordInvocation("GetUserByEmail", []interface{}{arg1, arg2})
	fake.getUserByEmailMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) GetUserByEmailCallCount() int {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	return len(fake.getUserByEmailArgsForCall)
}

func (fake *FakeUserSqlRepo) GetUserByEmailCalls(stub func(context.Context, string) (*model.User, error)) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = stub
}

func (fake *FakeUserSqlRepo) GetUserByEmailArgsForCall(i int) (context.Context, string) {
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	argsForCall := fake.getUserByEmailArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) GetUserByEmailReturns(result1 *model.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	fake.getUserByEmailReturns = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByEmailReturnsOnCall(i int, result1 *model.User, result2 error) {
	fake.getUserByEmailMutex.Lock()
	defer fake.getUserByEmailMutex.Unlock()
	fake.GetUserByEmailStub = nil
	if fake.getUserByEmailReturnsOnCall == nil {
		fake.getUserByEmailReturnsOnCall = make(map[int]struct {
			result1 *model.User
			result2 error
		})
	}
	fake.getUserByEmailReturnsOnCall[i] = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByEmailOrUsername(arg1 context.Context, arg2 string) (*model.User, error) {
	fake.getUserByEmailOrUsernameMutex.Lock()
	ret, specificReturn := fake.getUserByEmailOrUsernameReturnsOnCall[len(fake.getUserByEmailOrUsernameArgsForCall)]
	fake.getUserByEmailOrUsernameArgsForCall = append(fake.getUserByEmailOrUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByEmailOrUsernameStub
	fakeReturns := fake.getUserByEmailOrUsernameReturns
	fake.recordInvocation("GetUserByEmailOrUsername", []interface{}{arg1, arg2})
	fake.getUserByEmailOrUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) GetUserByEmailOrUsernameCallCount() int {
	fake.getUserByEmailOrUsernameMutex.RLock()
	defer fake.getUserByEmailOrUsernameMutex.RUnlock()
	return len(fake.getUserByEmailOrUsernameArgsForCall)
}

func (fake *FakeUserSqlRepo) GetUserByEmailOrUsernameCalls(stub func(context.Context, string) (*model.User, error)) {
	fake.getUserByEmailOrUsernameMutex.Lock()
	defer fake.getUserByEmailOrUsernameMutex.Unlock()
	fake.GetUserByEmailOrUsernameStub = stub
}

func (fake *FakeUserSqlRepo) GetUserByEmailOrUsernameArgsForCall(i int) (context.Context, string) {
	fake.getUserByEmailOrUsernameMutex.RLock()
	defer fake.getUserByEmailOrUsernameMutex.RUnlock()
	argsForCall := fake.getUserByEmailOrUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) GetUserByEmailOrUsernameReturns(result1 *model.User, result2 error) {
	fake.getUserByEmailOrUsernameMutex.Lock()
	defer fake.getUserByEmailOrUsernameMutex.Unlock()
	fake.GetUserByEmailOrUsernameStub = nil
	fake.getUserByEmailOrUsernameReturns = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByEmailOrUsernameReturnsOnCall(i int, result1 *model.User, result2 error) {
	fake.getUserByEmailOrUsernameMutex.Lock()
	defer fake.getUserByEmailOrUsernameMutex.Unlock()
	fake.GetUserByEmailOrUsernameStub = nil
	if fake.getUserByEmailOrUsernameReturnsOnCall == nil {
		fake.getUserByEmailOrUsernameReturnsOnCall = make(map[int]struct {
			result1 *model.User
			result2 error
		})
	}
	fake.getUserByEmailOrUsernameReturnsOnCall[i] = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByID(arg1 context.Context, arg2 string) (*model.User, error) {
	fake.getUserByIDMutex.Lock()
	ret, specificReturn := fake.getUserByIDReturnsOnCall[len(fake.getUserByIDArgsForCall)]
	fake.getUserByIDArgsForCall = append(fake.getUserByIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByIDStub
	fakeReturns := fake.getUserByIDReturns
	fake.recordInvocation("GetUserByID", []interface{}{arg1, arg2})
	fake.getUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) GetUserByIDCallCount() int {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	return len(fake.getUserByIDArgsForCall)
}

func (fake *FakeUserSqlRepo) GetUserByIDCalls(stub func(context.Context, string) (*model.User, error)) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = stub
}

func (fake *FakeUserSqlRepo) GetUserByIDArgsForCall(i int) (context.Context, string) {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	argsForCall := fake.getUserByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) GetUserByIDReturns(result1 *model.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	fake.getUserByIDReturns = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByIDReturnsOnCall(i int, result1 *model.User, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	if fake.getUserByIDReturnsOnCall == nil {
		fake.getUserByIDReturnsOnCall = make(map[int]struct {
			result1 *model.User
			result2 error
		})
	}
	fake.getUserByIDReturnsOnCall[i] = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByUsername(arg1 context.Context, arg2 string) (*model.User, error) {
	fake.getUserByUsernameMutex.Lock()
	ret, specificReturn := fake.getUserByUsernameReturnsOnCall[len(fake.getUserByUsernameArgsForCall)]
	fake.getUserByUsernameArgsForCall = append(fake.getUserByUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByUsernameStub
	fakeReturns := fake.getUserByUsernameReturns
	fake.recordInvocation("GetUserByUsername", []interface{}{arg1, arg2})
	fake.getUserByUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserSqlRepo) GetUserByUsernameCallCount() int {
	fake.getUserByUsernameMutex.RLock()
	defer fake.getUserByUsernameMutex.RUnlock()
	return len(fake.getUserByUsernameArgsForCall)
}

func (fake *FakeUserSqlRepo) GetUserByUsernameCalls(stub func(context.Context, string) (*model.User, error)) {
	fake.getUserByUsernameMutex.Lock()
	defer fake.getUserByUsernameMutex.Unlock()
	fake.GetUserByUsernameStub = stub
}

func (fake *FakeUserSqlRepo) GetUserByUsernameArgsForCall(i int) (context.Context, string) {
	fake.getUserByUsernameMutex.RLock()
	defer fake.getUserByUsernameMutex.RUnlock()
	argsForCall := fake.getUserByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) GetUserByUsernameReturns(result1 *model.User, result2 error) {
	fake.getUserByUsernameMutex.Lock()
	defer fake.getUserByUsernameMutex.Unlock()
	fake.GetUserByUsernameStub = nil
	fake.getUserByUsernameReturns = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) GetUserByUsernameReturnsOnCall(i int, result1 *model.User, result2 error) {
	fake.getUserByUsernameMutex.Lock()
	defer fake.getUserByUsernameMutex.Unlock()
	fake.GetUserByUsernameStub = nil
	if fake.getUserByUsernameReturnsOnCall == nil {
		fake.getUserByUsernameReturnsOnCall = make(map[int]struct {
			result1 *model.User
			result2 error
		})
	}
	fake.getUserByUsernameReturnsOnCall[i] = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserSqlRepo) OpenConn(arg1 context.Context) error {
	fake.openConnMutex.Lock()
	ret, specificReturn := fake.openConnReturnsOnCall[len(fake.openConnArgsForCall)]
	fake.openConnArgsForCall = append(fake.openConnArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.OpenConnStub
	fakeReturns := fake.openConnReturns
	fake.recordInvocation("OpenConn", []interface{}{arg1})
	fake.openConnMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserSqlRepo) OpenConnCallCount() int {
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	return len(fake.openConnArgsForCall)
}

func (fake *FakeUserSqlRepo) OpenConnCalls(stub func(context.Context) error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = stub
}

func (fake *FakeUserSqlRepo) OpenConnArgsForCall(i int) context.Context {
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	argsForCall := fake.openConnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserSqlRepo) OpenConnReturns(result1 error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = nil
	fake.openConnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) OpenConnReturnsOnCall(i int, result1 error) {
	fake.openConnMutex.Lock()
	defer fake.openConnMutex.Unlock()
	fake.OpenConnStub = nil
	if fake.openConnReturnsOnCall == nil {
		fake.openConnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openConnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) StartTx(arg1 context.Context, arg2 *sql.TxOptions) error {
	fake.startTxMutex.Lock()
	ret, specificReturn := fake.startTxReturnsOnCall[len(fake.startTxArgsForCall)]
	fake.startTxArgsForCall = append(fake.startTxArgsForCall, struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}{arg1, arg2})
	stub := fake.StartTxStub
	fakeReturns := fake.startTxReturns
	fake.recordInvocation("StartTx", []interface{}{arg1, arg2})
	fake.startTxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserSqlRepo) StartTxCallCount() int {
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	return len(fake.startTxArgsForCall)
}

func (fake *FakeUserSqlRepo) StartTxCalls(stub func(context.Context, *sql.TxOptions) error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = stub
}

func (fake *FakeUserSqlRepo) StartTxArgsForCall(i int) (context.Context, *sql.TxOptions) {
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	argsForCall := fake.startTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) StartTxReturns(result1 error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = nil
	fake.startTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) StartTxReturnsOnCall(i int, result1 error) {
	fake.startTxMutex.Lock()
	defer fake.startTxMutex.Unlock()
	fake.StartTxStub = nil
	if fake.startTxReturnsOnCall == nil {
		fake.startTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) UpdateActivasiUser(arg1 context.Context, arg2 *model.User) error {
	fake.updateActivasiUserMutex.Lock()
	ret, specificReturn := fake.updateActivasiUserReturnsOnCall[len(fake.updateActivasiUserArgsForCall)]
	fake.updateActivasiUserArgsForCall = append(fake.updateActivasiUserArgsForCall, struct {
		arg1 context.Context
		arg2 *model.User
	}{arg1, arg2})
	stub := fake.UpdateActivasiUserStub
	fakeReturns := fake.updateActivasiUserReturns
	fake.recordInvocation("UpdateActivasiUser", []interface{}{arg1, arg2})
	fake.updateActivasiUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserSqlRepo) UpdateActivasiUserCallCount() int {
	fake.updateActivasiUserMutex.RLock()
	defer fake.updateActivasiUserMutex.RUnlock()
	return len(fake.updateActivasiUserArgsForCall)
}

func (fake *FakeUserSqlRepo) UpdateActivasiUserCalls(stub func(context.Context, *model.User) error) {
	fake.updateActivasiUserMutex.Lock()
	defer fake.updateActivasiUserMutex.Unlock()
	fake.UpdateActivasiUserStub = stub
}

func (fake *FakeUserSqlRepo) UpdateActivasiUserArgsForCall(i int) (context.Context, *model.User) {
	fake.updateActivasiUserMutex.RLock()
	defer fake.updateActivasiUserMutex.RUnlock()
	argsForCall := fake.updateActivasiUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) UpdateActivasiUserReturns(result1 error) {
	fake.updateActivasiUserMutex.Lock()
	defer fake.updateActivasiUserMutex.Unlock()
	fake.UpdateActivasiUserStub = nil
	fake.updateActivasiUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) UpdateActivasiUserReturnsOnCall(i int, result1 error) {
	fake.updateActivasiUserMutex.Lock()
	defer fake.updateActivasiUserMutex.Unlock()
	fake.UpdateActivasiUserStub = nil
	if fake.updateActivasiUserReturnsOnCall == nil {
		fake.updateActivasiUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateActivasiUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) UpdatePasswordUser(arg1 context.Context, arg2 *model.User) error {
	fake.updatePasswordUserMutex.Lock()
	ret, specificReturn := fake.updatePasswordUserReturnsOnCall[len(fake.updatePasswordUserArgsForCall)]
	fake.updatePasswordUserArgsForCall = append(fake.updatePasswordUserArgsForCall, struct {
		arg1 context.Context
		arg2 *model.User
	}{arg1, arg2})
	stub := fake.UpdatePasswordUserStub
	fakeReturns := fake.updatePasswordUserReturns
	fake.recordInvocation("UpdatePasswordUser", []interface{}{arg1, arg2})
	fake.updatePasswordUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserSqlRepo) UpdatePasswordUserCallCount() int {
	fake.updatePasswordUserMutex.RLock()
	defer fake.updatePasswordUserMutex.RUnlock()
	return len(fake.updatePasswordUserArgsForCall)
}

func (fake *FakeUserSqlRepo) UpdatePasswordUserCalls(stub func(context.Context, *model.User) error) {
	fake.updatePasswordUserMutex.Lock()
	defer fake.updatePasswordUserMutex.Unlock()
	fake.UpdatePasswordUserStub = stub
}

func (fake *FakeUserSqlRepo) UpdatePasswordUserArgsForCall(i int) (context.Context, *model.User) {
	fake.updatePasswordUserMutex.RLock()
	defer fake.updatePasswordUserMutex.RUnlock()
	argsForCall := fake.updatePasswordUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserSqlRepo) UpdatePasswordUserReturns(result1 error) {
	fake.updatePasswordUserMutex.Lock()
	defer fake.updatePasswordUserMutex.Unlock()
	fake.UpdatePasswordUserStub = nil
	fake.updatePasswordUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) UpdatePasswordUserReturnsOnCall(i int, result1 error) {
	fake.updatePasswordUserMutex.Lock()
	defer fake.updatePasswordUserMutex.Unlock()
	fake.UpdatePasswordUserStub = nil
	if fake.updatePasswordUserReturnsOnCall == nil {
		fake.updatePasswordUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePasswordUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserSqlRepo) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkActivasiUserByIDMutex.RLock()
	defer fake.checkActivasiUserByIDMutex.RUnlock()
	fake.checkUserByEmailMutex.RLock()
	defer fake.checkUserByEmailMutex.RUnlock()
	fake.checkUserByUsernameMutex.RLock()
	defer fake.checkUserByUsernameMutex.RUnlock()
	fake.closeConnMutex.RLock()
	defer fake.closeConnMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.endTxMutex.RLock()
	defer fake.endTxMutex.RUnlock()
	fake.getConnMutex.RLock()
	defer fake.getConnMutex.RUnlock()
	fake.getTxMutex.RLock()
	defer fake.getTxMutex.RUnlock()
	fake.getUserByEmailMutex.RLock()
	defer fake.getUserByEmailMutex.RUnlock()
	fake.getUserByEmailOrUsernameMutex.RLock()
	defer fake.getUserByEmailOrUsernameMutex.RUnlock()
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	fake.getUserByUsernameMutex.RLock()
	defer fake.getUserByUsernameMutex.RUnlock()
	fake.openConnMutex.RLock()
	defer fake.openConnMutex.RUnlock()
	fake.startTxMutex.RLock()
	defer fake.startTxMutex.RUnlock()
	fake.updateActivasiUserMutex.RLock()
	defer fake.updateActivasiUserMutex.RUnlock()
	fake.updatePasswordUserMutex.RLock()
	defer fake.updatePasswordUserMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserSqlRepo) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repository.UserSqlRepo = new(FakeUserSqlRepo)

// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/DueIt-Jasanya-Aturuang/doraemon/domain/dto"
	"github.com/DueIt-Jasanya-Aturuang/doraemon/domain/usecase"
)

type FakeUserUsecase struct {
	ActivasiAccountStub        func(context.Context, string) (*dto.ActivasiAccountResp, error)
	activasiAccountMutex       sync.RWMutex
	activasiAccountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	activasiAccountReturns struct {
		result1 *dto.ActivasiAccountResp
		result2 error
	}
	activasiAccountReturnsOnCall map[int]struct {
		result1 *dto.ActivasiAccountResp
		result2 error
	}
	ForgottenPasswordStub        func(context.Context, *dto.ForgottenPasswordReq) (string, error)
	forgottenPasswordMutex       sync.RWMutex
	forgottenPasswordArgsForCall []struct {
		arg1 context.Context
		arg2 *dto.ForgottenPasswordReq
	}
	forgottenPasswordReturns struct {
		result1 string
		result2 error
	}
	forgottenPasswordReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ResetForgottenPasswordStub        func(context.Context, *dto.ResetForgottenPasswordReq) error
	resetForgottenPasswordMutex       sync.RWMutex
	resetForgottenPasswordArgsForCall []struct {
		arg1 context.Context
		arg2 *dto.ResetForgottenPasswordReq
	}
	resetForgottenPasswordReturns struct {
		result1 error
	}
	resetForgottenPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	ResetPasswordStub        func(context.Context, *dto.ResetPasswordReq) error
	resetPasswordMutex       sync.RWMutex
	resetPasswordArgsForCall []struct {
		arg1 context.Context
		arg2 *dto.ResetPasswordReq
	}
	resetPasswordReturns struct {
		result1 error
	}
	resetPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserUsecase) ActivasiAccount(arg1 context.Context, arg2 string) (*dto.ActivasiAccountResp, error) {
	fake.activasiAccountMutex.Lock()
	ret, specificReturn := fake.activasiAccountReturnsOnCall[len(fake.activasiAccountArgsForCall)]
	fake.activasiAccountArgsForCall = append(fake.activasiAccountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ActivasiAccountStub
	fakeReturns := fake.activasiAccountReturns
	fake.recordInvocation("ActivasiAccount", []interface{}{arg1, arg2})
	fake.activasiAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserUsecase) ActivasiAccountCallCount() int {
	fake.activasiAccountMutex.RLock()
	defer fake.activasiAccountMutex.RUnlock()
	return len(fake.activasiAccountArgsForCall)
}

func (fake *FakeUserUsecase) ActivasiAccountCalls(stub func(context.Context, string) (*dto.ActivasiAccountResp, error)) {
	fake.activasiAccountMutex.Lock()
	defer fake.activasiAccountMutex.Unlock()
	fake.ActivasiAccountStub = stub
}

func (fake *FakeUserUsecase) ActivasiAccountArgsForCall(i int) (context.Context, string) {
	fake.activasiAccountMutex.RLock()
	defer fake.activasiAccountMutex.RUnlock()
	argsForCall := fake.activasiAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserUsecase) ActivasiAccountReturns(result1 *dto.ActivasiAccountResp, result2 error) {
	fake.activasiAccountMutex.Lock()
	defer fake.activasiAccountMutex.Unlock()
	fake.ActivasiAccountStub = nil
	fake.activasiAccountReturns = struct {
		result1 *dto.ActivasiAccountResp
		result2 error
	}{result1, result2}
}

func (fake *FakeUserUsecase) ActivasiAccountReturnsOnCall(i int, result1 *dto.ActivasiAccountResp, result2 error) {
	fake.activasiAccountMutex.Lock()
	defer fake.activasiAccountMutex.Unlock()
	fake.ActivasiAccountStub = nil
	if fake.activasiAccountReturnsOnCall == nil {
		fake.activasiAccountReturnsOnCall = make(map[int]struct {
			result1 *dto.ActivasiAccountResp
			result2 error
		})
	}
	fake.activasiAccountReturnsOnCall[i] = struct {
		result1 *dto.ActivasiAccountResp
		result2 error
	}{result1, result2}
}

func (fake *FakeUserUsecase) ForgottenPassword(arg1 context.Context, arg2 *dto.ForgottenPasswordReq) (string, error) {
	fake.forgottenPasswordMutex.Lock()
	ret, specificReturn := fake.forgottenPasswordReturnsOnCall[len(fake.forgottenPasswordArgsForCall)]
	fake.forgottenPasswordArgsForCall = append(fake.forgottenPasswordArgsForCall, struct {
		arg1 context.Context
		arg2 *dto.ForgottenPasswordReq
	}{arg1, arg2})
	stub := fake.ForgottenPasswordStub
	fakeReturns := fake.forgottenPasswordReturns
	fake.recordInvocation("ForgottenPassword", []interface{}{arg1, arg2})
	fake.forgottenPasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserUsecase) ForgottenPasswordCallCount() int {
	fake.forgottenPasswordMutex.RLock()
	defer fake.forgottenPasswordMutex.RUnlock()
	return len(fake.forgottenPasswordArgsForCall)
}

func (fake *FakeUserUsecase) ForgottenPasswordCalls(stub func(context.Context, *dto.ForgottenPasswordReq) (string, error)) {
	fake.forgottenPasswordMutex.Lock()
	defer fake.forgottenPasswordMutex.Unlock()
	fake.ForgottenPasswordStub = stub
}

func (fake *FakeUserUsecase) ForgottenPasswordArgsForCall(i int) (context.Context, *dto.ForgottenPasswordReq) {
	fake.forgottenPasswordMutex.RLock()
	defer fake.forgottenPasswordMutex.RUnlock()
	argsForCall := fake.forgottenPasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserUsecase) ForgottenPasswordReturns(result1 string, result2 error) {
	fake.forgottenPasswordMutex.Lock()
	defer fake.forgottenPasswordMutex.Unlock()
	fake.ForgottenPasswordStub = nil
	fake.forgottenPasswordReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserUsecase) ForgottenPasswordReturnsOnCall(i int, result1 string, result2 error) {
	fake.forgottenPasswordMutex.Lock()
	defer fake.forgottenPasswordMutex.Unlock()
	fake.ForgottenPasswordStub = nil
	if fake.forgottenPasswordReturnsOnCall == nil {
		fake.forgottenPasswordReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.forgottenPasswordReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserUsecase) ResetForgottenPassword(arg1 context.Context, arg2 *dto.ResetForgottenPasswordReq) error {
	fake.resetForgottenPasswordMutex.Lock()
	ret, specificReturn := fake.resetForgottenPasswordReturnsOnCall[len(fake.resetForgottenPasswordArgsForCall)]
	fake.resetForgottenPasswordArgsForCall = append(fake.resetForgottenPasswordArgsForCall, struct {
		arg1 context.Context
		arg2 *dto.ResetForgottenPasswordReq
	}{arg1, arg2})
	stub := fake.ResetForgottenPasswordStub
	fakeReturns := fake.resetForgottenPasswordReturns
	fake.recordInvocation("ResetForgottenPassword", []interface{}{arg1, arg2})
	fake.resetForgottenPasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserUsecase) ResetForgottenPasswordCallCount() int {
	fake.resetForgottenPasswordMutex.RLock()
	defer fake.resetForgottenPasswordMutex.RUnlock()
	return len(fake.resetForgottenPasswordArgsForCall)
}

func (fake *FakeUserUsecase) ResetForgottenPasswordCalls(stub func(context.Context, *dto.ResetForgottenPasswordReq) error) {
	fake.resetForgottenPasswordMutex.Lock()
	defer fake.resetForgottenPasswordMutex.Unlock()
	fake.ResetForgottenPasswordStub = stub
}

func (fake *FakeUserUsecase) ResetForgottenPasswordArgsForCall(i int) (context.Context, *dto.ResetForgottenPasswordReq) {
	fake.resetForgottenPasswordMutex.RLock()
	defer fake.resetForgottenPasswordMutex.RUnlock()
	argsForCall := fake.resetForgottenPasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserUsecase) ResetForgottenPasswordReturns(result1 error) {
	fake.resetForgottenPasswordMutex.Lock()
	defer fake.resetForgottenPasswordMutex.Unlock()
	fake.ResetForgottenPasswordStub = nil
	fake.resetForgottenPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserUsecase) ResetForgottenPasswordReturnsOnCall(i int, result1 error) {
	fake.resetForgottenPasswordMutex.Lock()
	defer fake.resetForgottenPasswordMutex.Unlock()
	fake.ResetForgottenPasswordStub = nil
	if fake.resetForgottenPasswordReturnsOnCall == nil {
		fake.resetForgottenPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetForgottenPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserUsecase) ResetPassword(arg1 context.Context, arg2 *dto.ResetPasswordReq) error {
	fake.resetPasswordMutex.Lock()
	ret, specificReturn := fake.resetPasswordReturnsOnCall[len(fake.resetPasswordArgsForCall)]
	fake.resetPasswordArgsForCall = append(fake.resetPasswordArgsForCall, struct {
		arg1 context.Context
		arg2 *dto.ResetPasswordReq
	}{arg1, arg2})
	stub := fake.ResetPasswordStub
	fakeReturns := fake.resetPasswordReturns
	fake.recordInvocation("ResetPassword", []interface{}{arg1, arg2})
	fake.resetPasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserUsecase) ResetPasswordCallCount() int {
	fake.resetPasswordMutex.RLock()
	defer fake.resetPasswordMutex.RUnlock()
	return len(fake.resetPasswordArgsForCall)
}

func (fake *FakeUserUsecase) ResetPasswordCalls(stub func(context.Context, *dto.ResetPasswordReq) error) {
	fake.resetPasswordMutex.Lock()
	defer fake.resetPasswordMutex.Unlock()
	fake.ResetPasswordStub = stub
}

func (fake *FakeUserUsecase) ResetPasswordArgsForCall(i int) (context.Context, *dto.ResetPasswordReq) {
	fake.resetPasswordMutex.RLock()
	defer fake.resetPasswordMutex.RUnlock()
	argsForCall := fake.resetPasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserUsecase) ResetPasswordReturns(result1 error) {
	fake.resetPasswordMutex.Lock()
	defer fake.resetPasswordMutex.Unlock()
	fake.ResetPasswordStub = nil
	fake.resetPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserUsecase) ResetPasswordReturnsOnCall(i int, result1 error) {
	fake.resetPasswordMutex.Lock()
	defer fake.resetPasswordMutex.Unlock()
	fake.ResetPasswordStub = nil
	if fake.resetPasswordReturnsOnCall == nil {
		fake.resetPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserUsecase) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activasiAccountMutex.RLock()
	defer fake.activasiAccountMutex.RUnlock()
	fake.forgottenPasswordMutex.RLock()
	defer fake.forgottenPasswordMutex.RUnlock()
	fake.resetForgottenPasswordMutex.RLock()
	defer fake.resetForgottenPasswordMutex.RUnlock()
	fake.resetPasswordMutex.RLock()
	defer fake.resetPasswordMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserUsecase) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ usecase.UserUsecase = new(FakeUserUsecase)
